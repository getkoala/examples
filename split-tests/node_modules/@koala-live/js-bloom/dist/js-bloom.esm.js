function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _createForOfIteratorHelperLoose(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (it) return (it = it.call(o)).next.bind(it);

  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
    if (it) o = it;
    var i = 0;
    return function () {
      if (i >= o.length) return {
        done: true
      };
      return {
        done: false,
        value: o[i++]
      };
    };
  }

  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

var ELEMENT_WIDTH = 32;
var BA = /*#__PURE__*/function () {
  function BA(size, field) {
    this.size = void 0;
    this.field = void 0;
    this.size = size;
    this.field = field;
    this.size = size;
    this.field = field || [];
    var arrayLength = Math.floor((size - 1) / ELEMENT_WIDTH + 1);

    if (!field) {
      for (var i = 0, end = arrayLength - 1, asc = 0 <= end; asc ? i <= end : i >= end; asc ? i++ : i--) {
        this.field[i] = 0;
      }
    }
  }

  var _proto = BA.prototype;

  _proto.add = function add(position) {
    return this.set(position, 1);
  };

  _proto.remove = function remove(position) {
    return this.set(position, 0);
  };

  _proto.set = function set(position, value) {
    if (position >= this.size) {
      throw new Error('BitArray index out of bounds');
    }

    var aPos = arrayPosition(position);
    var bChange = bitChange(position);

    if (value === 1) {
      this.field[aPos] = abs(this.field[aPos] | bChange);
    } else if ((this.field[aPos] & bChange) !== 0) {
      this.field[aPos] = abs(this.field[aPos] ^ bChange);
    }

    return true;
  };

  _proto.get = function get(position) {
    if (position >= this.size) {
      throw new Error('BitArray index out of bounds');
    }

    var aPos = arrayPosition(position);
    var bChange = bitChange(position);

    if (abs(this.field[aPos] & bChange) > 0) {
      return 1;
    } else {
      return 0;
    }
  };

  return BA;
}();

function arrayPosition(position) {
  return Math.floor(position / ELEMENT_WIDTH);
}

function bitChange(position) {
  return abs(1 << position % ELEMENT_WIDTH);
}

function abs(val) {
  if (val < 0) {
    val += 4294967295;
  }

  return val;
}

function crcTable() {
  var c;
  var crcTable = [];

  for (var n = 0; n < 256; n++) {
    c = n;

    for (var k = 0; k < 8; k++) {
      c = c & 1 ? 0xedb88320 ^ c >>> 1 : c >>> 1;
    }

    crcTable[n] = c;
  }

  return crcTable;
}

var CRC32_TABLE = /*#__PURE__*/crcTable();
var crc32 = function crc32(string) {
  var bytes = bytesFor(string);
  var crc = 0;
  var n = 0;
  crc = crc ^ -1;
  var i = 0;
  var iTop = bytes.length;

  while (i < iTop) {
    n = (crc ^ bytes[i]) & 0xff;
    crc = crc >>> 8 ^ CRC32_TABLE[n];
    i++;
  }

  crc = crc ^ -1;

  if (crc < 0) {
    crc += 4294967296;
  }

  return crc;
};

var bytesFor = function bytesFor(string) {
  var bytes = [];
  var i = 0;

  while (i < string.length) {
    bytes.push(string.charCodeAt(i));
    ++i;
  }

  return bytes;
};

var JsBloom = /*#__PURE__*/function () {
  function JsBloom(options) {
    if (options === void 0) {
      options = {};
    }

    this.options = void 0;
    this.bits = void 0;
    this.options = options;
    this.options = _extends({
      size: 100,
      hashes: 4,
      seed: new Date().getTime() / 1000,
      bits: null
    }, options);
    this.bits = new BA(this.options['size'], this.options['bits']);
  }

  var _proto = JsBloom.prototype;

  _proto.add = function add() {
    for (var _len = arguments.length, keys = new Array(_len), _key = 0; _key < _len; _key++) {
      keys[_key] = arguments[_key];
    }

    for (var _i = 0, _keys = keys; _i < _keys.length; _i++) {
      var key = _keys[_i];

      for (var _i2 = 0, _Array$from = Array.from(this.indexesFor(key)); _i2 < _Array$from.length; _i2++) {
        var index = _Array$from[_i2];
        this.bits.add(index);
      }
    }
  };

  _proto.test = function test() {
    for (var _len2 = arguments.length, keys = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      keys[_key2] = arguments[_key2];
    }

    for (var _i3 = 0, _keys2 = keys; _i3 < _keys2.length; _i3++) {
      var key = _keys2[_i3];

      for (var _iterator = _createForOfIteratorHelperLoose(this.indexesFor(key)), _step; !(_step = _iterator()).done;) {
        var index = _step.value;

        if (this.bits.get(index) === 0) {
          return false;
        }
      }
    }

    return true;
  };

  _proto.toHash = function toHash() {
    return {
      size: this.options['size'],
      hashes: this.options['hashes'],
      seed: this.options['seed'],
      bits: this.bits.field
    };
  };

  _proto.toJson = function toJson() {
    return JSON.stringify(this.toHash());
  };

  _proto.indexesFor = function indexesFor(key) {
    var indexes = [];

    for (var index = 0, end = this.options['hashes'] - 1, asc = 0 <= end; asc ? index <= end : index >= end; asc ? index++ : index--) {
      indexes.push(crc32(key + ":" + (index + this.options['seed'])) % this.options['size']);
    }

    return indexes;
  };

  return JsBloom;
}();

var MAX_FIXNUM = Number.MAX_SAFE_INTEGER - 1;

function createData(k, m) {
  var data = new Array(k);

  for (var i = 0; i < k; i++) {
    data[i] = new Uint32Array(m);
  }

  return data;
}

function convertData(data) {
  return data.map(function (k) {
    return Uint32Array.from(k);
  });
}

function toArray(data) {
  return data.map(function (k) {
    return Array.from(k);
  });
}

function seeds(k) {
  var seeds = new Array(k);

  for (var i = 0; i < k; i++) {
    seeds[i] = Math.random() * (MAX_FIXNUM + 1);
  }

  return seeds;
}

var DEFAULTS = {
  size: 100,
  hashes: 4
};
var CountMinSketch = /*#__PURE__*/function () {
  function CountMinSketch(options) {
    if (options === void 0) {
      options = {};
    }

    this.options = void 0;
    this.k = void 0;
    this.m = void 0;
    this.data = void 0;
    this.seeds = void 0;
    this.options = Object.assign({}, DEFAULTS, options);
    this.k = this.options.hashes;
    this.m = this.options.size;
    this.data = this.options.data ? convertData(this.options.data) : createData(this.k, this.m);
    this.seeds = this.options.seeds || seeds(this.k);
  }

  var _proto = CountMinSketch.prototype;

  _proto.count = function count(item) {
    return this.add(item, 0);
  };

  _proto.add = function add(item, n) {
    var _this = this;

    if (n === void 0) {
      n = 1;
    }

    var minCount = Infinity;
    this.seeds.forEach(function (seed, i) {
      var hash = crc32(item + ":" + (seed + i));
      var j = hash % _this.m;
      var cnt = _this.data[i][j] += n;

      if (cnt < minCount) {
        minCount = cnt;
      }
    });
    return minCount;
  };

  _proto.setCount = function setCount(item, n) {
    this.add(item, n - this.count(item));
  };

  _proto.toHash = function toHash() {
    return Object.assign({}, this.options, {
      data: toArray(this.data),
      seeds: this.seeds
    });
  };

  _proto.toJSON = function toJSON() {
    return JSON.stringify(this.toHash());
  };

  return CountMinSketch;
}();

export { CountMinSketch, JsBloom };
//# sourceMappingURL=js-bloom.esm.js.map
